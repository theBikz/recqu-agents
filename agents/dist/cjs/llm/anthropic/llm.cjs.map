{"version":3,"file":"llm.cjs","sources":["../../../../src/llm/anthropic/llm.ts"],"sourcesContent":["import { AIMessageChunk } from '@langchain/core/messages';\nimport { ChatAnthropicMessages } from '@langchain/anthropic';\nimport { ChatGenerationChunk } from '@langchain/core/outputs';\nimport type { BaseMessage, MessageContentComplex } from '@langchain/core/messages';\nimport type { CallbackManagerForLLMRun } from '@langchain/core/callbacks/manager';\nimport type { AnthropicInput } from '@langchain/anthropic';\nimport type { AnthropicMessageCreateParams, AnthropicStreamUsage, AnthropicMessageStartEvent, AnthropicMessageDeltaEvent } from '@/llm/anthropic/types';\nimport { _makeMessageChunkFromAnthropicEvent } from './utils/message_outputs';\nimport { _convertMessagesToAnthropicPayload } from './utils/message_inputs';\nimport { TextStream } from '@/llm/text';\n\nfunction _toolsInParams(params: AnthropicMessageCreateParams): boolean {\n  return !!(params.tools && params.tools.length > 0);\n}\n\nfunction extractToken(chunk: AIMessageChunk): [string, 'string' | 'input' | 'content'] | [undefined] {\n  if (typeof chunk.content === 'string') {\n    return [chunk.content, 'string'];\n  } else if (\n    Array.isArray(chunk.content) &&\n    chunk.content.length >= 1 &&\n    'input' in chunk.content[0]\n  ) {\n    return typeof chunk.content[0].input === 'string'\n      ? [chunk.content[0].input, 'input']\n      : [JSON.stringify(chunk.content[0].input), 'input'];\n  } else if (\n    Array.isArray(chunk.content) &&\n    chunk.content.length >= 1 &&\n    'text' in chunk.content[0]\n  ) {\n    return [chunk.content[0].text, 'content'];\n  }\n  return [undefined];\n}\n\nfunction cloneChunk(text: string, tokenType: string, chunk: AIMessageChunk): AIMessageChunk {\n  if (tokenType === 'string') {\n    return new AIMessageChunk(Object.assign({}, chunk, { content: text }));\n  } else if (tokenType === 'input') {\n    return chunk;\n  }\n  const content = chunk.content[0] as MessageContentComplex;\n  if (tokenType === 'content' && content.type === 'text') {\n    return new AIMessageChunk(Object.assign({}, chunk, { content: [Object.assign({}, content, { text })] }));\n  } else if (tokenType === 'content' && content.type === 'text_delta') {\n    return new AIMessageChunk(Object.assign({}, chunk, { content: [Object.assign({}, content, { text })] }));\n  }\n\n  return chunk;\n}\n\nexport type CustomAnthropicInput = AnthropicInput & { _lc_stream_delay?: number };\n\nexport class CustomAnthropic extends ChatAnthropicMessages {\n  _lc_stream_delay: number;\n  private message_start: AnthropicMessageStartEvent | undefined;\n  private message_delta: AnthropicMessageDeltaEvent | undefined;\n  private tools_in_params?: boolean;\n  private emitted_usage?: boolean;\n  constructor(fields: CustomAnthropicInput) {\n    super(fields);\n    this._lc_stream_delay = fields._lc_stream_delay ?? 25;\n  }\n\n  /**\n   * Get stream usage as returned by this client's API response.\n   * @returns {AnthropicStreamUsage} The stream usage object.\n   */\n  getStreamUsage(): AnthropicStreamUsage | undefined {\n    if (this.emitted_usage === true) {\n      return;\n    }\n    const inputUsage = (this.message_start?.message)?.usage as undefined | AnthropicStreamUsage;\n    const outputUsage = this.message_delta?.usage as undefined | Partial<AnthropicStreamUsage>;\n    if (!outputUsage) {\n      return;\n    }\n    const totalUsage = {\n      total_tokens: (inputUsage?.input_tokens ?? 0)\n      + (inputUsage?.output_tokens ?? 0)\n      + (inputUsage?.cache_creation_input_tokens ?? 0)\n      + (inputUsage?.cache_read_input_tokens ?? 0)\n      + (outputUsage.input_tokens ?? 0)\n      + (outputUsage.output_tokens ?? 0)\n      + (outputUsage.cache_creation_input_tokens ?? 0)\n      + (outputUsage.cache_read_input_tokens ?? 0),\n    };\n\n    this.emitted_usage = true;\n    return Object.assign(totalUsage, inputUsage, outputUsage);\n  }\n\n  resetTokenEvents(): void {\n    this.message_start = undefined;\n    this.message_delta = undefined;\n    this.emitted_usage = undefined;\n    this.tools_in_params = undefined;\n  }\n\n  private createGenerationChunk({\n    token,\n    chunk,\n    usageMetadata,\n    shouldStreamUsage,\n  }: {\n    token?: string,\n    chunk: AIMessageChunk,\n    shouldStreamUsage: boolean\n    usageMetadata?: AnthropicStreamUsage,\n  }): ChatGenerationChunk {\n    const usage_metadata = shouldStreamUsage ? usageMetadata ?? chunk.usage_metadata : undefined;\n    return new ChatGenerationChunk({\n      message: new AIMessageChunk({\n        // Just yield chunk as it is and tool_use will be concat by BaseChatModel._generateUncached().\n        content: chunk.content,\n        additional_kwargs: chunk.additional_kwargs,\n        tool_call_chunks: chunk.tool_call_chunks,\n        response_metadata: chunk.response_metadata,\n        usage_metadata,\n        id: chunk.id,\n      }),\n      text: token ?? '',\n    });\n  }\n\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this['ParsedCallOptions'],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const params = this.invocationParams(options);\n    const formattedMessages = _convertMessagesToAnthropicPayload(messages);\n    this.tools_in_params = _toolsInParams({\n      ...params,\n      ...formattedMessages,\n      stream: false,\n    });\n    const coerceContentToString = !this.tools_in_params;\n\n    const stream = await this.createStreamWithRetry(\n      {\n        ...params,\n        ...formattedMessages,\n        stream: true,\n      },\n      {\n        headers: options.headers,\n      }\n    );\n\n    const shouldStreamUsage = this.streamUsage ?? options.streamUsage;\n\n    for await (const data of stream) {\n      if (options.signal?.aborted === true) {\n        stream.controller.abort();\n        throw new Error('AbortError: User aborted the request.');\n      }\n\n      const type = data.type ?? '';\n      if (type === 'message_start') {\n        this.message_start = data as AnthropicMessageStartEvent;\n      } else if (type === 'message_delta') {\n        this.message_delta = data as AnthropicMessageDeltaEvent;\n      }\n\n      let usageMetadata: AnthropicStreamUsage | undefined;\n      if (this.tools_in_params !== true && this.emitted_usage !== true) {\n        usageMetadata = this.getStreamUsage();\n      }\n\n      const result = _makeMessageChunkFromAnthropicEvent(data, {\n        streamUsage: shouldStreamUsage,\n        coerceContentToString,\n      });\n      if (!result) continue;\n\n      const { chunk } = result;\n      const [token = '', tokenType] = extractToken(chunk);\n\n      if (!tokenType || tokenType === 'input' || (token === '' && usageMetadata)) {\n        const generationChunk = this.createGenerationChunk({\n          token,\n          chunk,\n          usageMetadata,\n          shouldStreamUsage,\n        });\n        yield generationChunk;\n        await runManager?.handleLLMNewToken(\n          token,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          { chunk: generationChunk }\n        );\n        continue;\n      }\n\n      const textStream = new TextStream(token, {\n        delay: this._lc_stream_delay,\n        firstWordChunk: true,\n        minChunkSize: 4,\n        maxChunkSize: 8,\n      });\n\n      const generator = textStream.generateText();\n      try {\n        let emittedUsage = false;\n        for await (const currentToken of generator) {\n          const newChunk = cloneChunk(currentToken, tokenType, chunk);\n\n          const generationChunk = this.createGenerationChunk({\n            token: currentToken,\n            chunk: newChunk,\n            usageMetadata: emittedUsage ? undefined : usageMetadata,\n            shouldStreamUsage,\n          });\n\n          if (usageMetadata && !emittedUsage) {\n            emittedUsage = true;\n          }\n          yield generationChunk;\n\n          await runManager?.handleLLMNewToken(\n            token,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            { chunk: generationChunk }\n          );\n        }\n      } finally {\n        await generator.return();\n      }\n    }\n\n    this.resetTokenEvents();\n  }\n}"],"names":["AIMessageChunk","ChatAnthropicMessages","ChatGenerationChunk","_convertMessagesToAnthropicPayload","_makeMessageChunkFromAnthropicEvent","TextStream"],"mappings":"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"}