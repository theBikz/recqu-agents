{"version":3,"file":"ToolNode.cjs","sources":["../../../src/tools/ToolNode.ts"],"sourcesContent":["import { END, MessagesAnnotation, isCommand, isGraphInterrupt } from '@langchain/langgraph';\nimport { ToolMessage, isBaseMessage } from '@langchain/core/messages';\nimport type { RunnableConfig, RunnableToolLike } from '@langchain/core/runnables';\nimport type { BaseMessage, AIMessage } from '@langchain/core/messages';\nimport type { StructuredToolInterface } from '@langchain/core/tools';\nimport type * as t from '@/types';\nimport{ RunnableCallable } from '@/utils';\nimport { GraphNodeKeys } from '@/common';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class ToolNode<T = any> extends RunnableCallable<T, T> {\n  tools: t.GenericTool[];\n  private toolMap: Map<string, StructuredToolInterface | RunnableToolLike>;\n  private loadRuntimeTools?: t.ToolRefGenerator;\n  handleToolErrors = true;\n  toolCallStepIds?: Map<string, string>;\n\n  constructor({\n    tools,\n    toolMap,\n    name,\n    tags,\n    toolCallStepIds,\n    handleToolErrors,\n    loadRuntimeTools,\n  }: t.ToolNodeConstructorParams) {\n    super({ name, tags, func: (input, config) => this.run(input, config) });\n    this.tools = tools;\n    this.toolMap = toolMap ?? new Map(tools.map(tool => [tool.name, tool]));\n    this.toolCallStepIds = toolCallStepIds;\n    this.handleToolErrors = handleToolErrors ?? this.handleToolErrors;\n    this.loadRuntimeTools = loadRuntimeTools;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected async run(input: any, config: RunnableConfig): Promise<T> {\n    const message = Array.isArray(input)\n      ? input[input.length - 1]\n      : input.messages[input.messages.length - 1];\n\n    if (message._getType() !== 'ai') {\n      throw new Error('ToolNode only accepts AIMessages as input.');\n    }\n\n    if (this.loadRuntimeTools) {\n      const { tools, toolMap } = this.loadRuntimeTools(\n        (message as AIMessage).tool_calls ?? []\n      );\n      this.tools = tools;\n      this.toolMap = toolMap ?? new Map(tools.map(tool => [tool.name, tool]));\n    }\n    const outputs = await Promise.all(\n      (message as AIMessage).tool_calls?.map(async (call) => {\n        const tool = this.toolMap.get(call.name);\n        try {\n          if (tool === undefined) {\n            throw new Error(`Tool \"${call.name}\" not found.`);\n          }\n          const args = call.args;\n          const stepId = this.toolCallStepIds?.get(call.id!);\n          const output = await tool.invoke(\n            { ...call, args, type: 'tool_call', stepId },\n            config,\n          );\n          if (\n            (isBaseMessage(output) && output._getType() === 'tool') ||\n            isCommand(output)\n          ) {\n            return output;\n          } else {\n            return new ToolMessage({\n              name: tool.name,\n              content:\n                typeof output === 'string' ? output : JSON.stringify(output),\n              tool_call_id: call.id!,\n            });\n          }\n        } catch (_e: unknown) {\n          const e = _e as Error;\n          if (!this.handleToolErrors) {\n            throw e;\n          }\n          if (isGraphInterrupt(e)) {\n            throw e;\n          }\n          return new ToolMessage({\n            content: `Error: ${e.message}\\n Please fix your mistakes.`,\n            name: call.name,\n            tool_call_id: call.id ?? '',\n          });\n        }\n      }) ?? []\n    );\n\n    if (!outputs.some(isCommand)) {\n      return (Array.isArray(input) ? outputs : { messages: outputs }) as T;\n    }\n\n    const combinedOutputs = outputs.map((output) => {\n      if (isCommand(output)) {\n        return output;\n      }\n      return Array.isArray(input) ? [output] : { messages: [output] };\n    });\n    return combinedOutputs as T;\n  }\n}\n\nexport function toolsCondition(\n  state: BaseMessage[] | typeof MessagesAnnotation.State\n): 'tools' | typeof END {\n  const message = Array.isArray(state)\n    ? state[state.length - 1]\n    : state.messages[state.messages.length - 1];\n\n  if (\n    'tool_calls' in message &&\n    ((message as AIMessage).tool_calls?.length ?? 0) > 0\n  ) {\n    return GraphNodeKeys.TOOLS;\n  } else {\n    return END;\n  }\n}"],"names":["RunnableCallable","isBaseMessage","isCommand","ToolMessage","isGraphInterrupt","GraphNodeKeys","END"],"mappings":"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"}